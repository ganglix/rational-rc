<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Tinkrete.chloride API documentation</title>
<meta name="description" content="TODO: make t input vectorized" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Tinkrete.chloride</code></h1>
</header>
<section id="section-intro">
<p>TODO: make t input vectorized</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
TODO: make t input vectorized 
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from scipy.special import erf

import matplotlib.pyplot as plt
import sys
from copy import deepcopy
import logging

import helper_func as hf


# logger
# log levels: NOTSET, DEBUG, INFO, WARNING, ERROR, and CRITICAL
LOG_FORMAT = &#34;%(levelname)s %(asctime)s - %(message)s&#34;
logging.basicConfig(
    filename=&#34;mylog.log&#34;,
    # level=logging.DEBUG,
    format=LOG_FORMAT,
)

logger = logging.getLogger(__name__)
logger.setLevel(
    logging.CRITICAL
)  # set logging level here to work in jupyter notebook where maybe a default setting was there


# model functions
def Chloride_content(x, t, pars):
    &#34;&#34;&#34; Master model function, calculate chloride content at depth x and time t with Fick&#39;s 2nd law below the convection zone (x &gt; dx)
    The derived parameters is also calculated within this funcion.
    Caution: The pars instance is mutable, so a deepcopy of the original instance should be used if the calculation is not intended for &#34;inplace&#34;.

    Parameters
    ----------
    x      : depth where chloride content is C_x_t [mm]
    t      : time [year]
    pars   : object/instance of wrapper class(empty class)
                a wrapper of all material and evironmental parameters deep-copied from the raw data

    Returns
    -------
    out : chloride content in concrete at a depth x (suface x=0) at time t [wt-.%/c]

    Notes
    -----
    intermediate parameters calcualted and attached to pars
    C_0    : initial chloride content of the concrete [wt-.%/cement]
    C_S_dx : chloride content at a depth dx and a certain point of time t [wt-.%/cement]
    dx     : depth of the convection zone (concrete layer, up to which the process of chloride penetration differs from Fick’s 2nd law of diffusion) [mm]
    D_app  : apparent coefficient of chloride diffusion through concxrete [mm^2/year]
    erf    : imported error function
    &#34;&#34;&#34;
    pars.D_app = D_app(t, pars)
    C_x_t = pars.C_0 + (pars.C_S_dx - pars.C_0) * (
        1 - erf((x - pars.dx) / (2 * (pars.D_app * t) ** 0.5))
    )
    return C_x_t


def D_app(t, pars):
    &#34;&#34;&#34; Calculate the apparent coefficient of chloride diffusion through concxrete D_app[mm^2/year]

    Parameters
    ----------
    t : time [year]
    pars   : object/instance of wrapper class(empty class)
               a wrapper of all material and evironmental parameters deep-copied from the raw data

    Returns
    -------
    out : numpy array
        apparent coefficient of chloride diffusion through concxrete [mm^2/year]

    Notes
    -----
    intermediate parameters calcualted and attached to pars
    k_e     : environmental transfer variable [-]
    D_RCM_0 : chloride migration coefficient [mm^2/year]
    k_t     : transfer parameter, k_t =1 was set in A_t()[-]
    A_t     : subfunction considering the &#39;ageing&#39; [-]
    &#34;&#34;&#34;
    pars.k_e = k_e(pars)
    pars.D_RCM_0 = D_RCM_0(pars)

    pars.A_t = A_t(t, pars)  # pars.k_t =1 was set in A_t()
    D_app = pars.k_e * pars.D_RCM_0 * pars.k_t * pars.A_t
    return D_app


def k_e(pars):
    &#34;&#34;&#34;Calculate k_e: environmental transfer variable [-]

    Parameters
    ----------
    pars.T_ref  : standard test temperatrure 293 [K]
    pars.T_real : temperature of the structural element [K]
    pars.b_e    : regression varible [K]
    &#34;&#34;&#34;
    pars.T_ref = 293  # K (20°C)
    pars.b_e = b_e()
    k_e = np.e ** (pars.b_e * (1 / pars.T_ref - 1 / pars.T_real))
    return k_e


def b_e():
    &#34;&#34;&#34;calculate b_e : regression varible [K]&#34;&#34;&#34;
    b_e = hf.Normal_custom(4800, 700)  # K
    return b_e


def A_t(t, pars):
    &#34;&#34;&#34;calcuate A_t considering the ageing effect

    Parameters
    ----------
    t : time [year]
    pars.concrete_type : string
                         &#39;Portland cement concrete&#39;,
                         &#39;Portland fly ash cement concrete&#39;,
                         &#39;Blast furnace slag cement concrete&#39;

    Returns
    -------
    out : numpy array
        subfunction considering the ‘ageing&#39;[-]

    Notes
    -----
    built-in parameters
    pars.k_t : transfer parameter, k_t =1 was set for experiment [-]
    pars.t_0 : reference point of time, 0.0767 [year]
    &#34;&#34;&#34;
    pars.t_0 = 0.0767  # reference point of time [year]
    # To carry out the quantification of a, the transfer variable k_t was set to k_t = 1:
    pars.k_t = 1
    # a: agieng exponent
    a = None
    if pars.concrete_type == &#34;Portland cement concrete&#34;:
        # CEM I; 0.40 ≤ w/c ≤ 0.60
        a = hf.Beta_custom(0.3, 0.12, 0.0, 1.0)

    if pars.concrete_type == &#34;Portland fly ash cement concrete&#34;:
        # f≥0.20·z;k=0.50; 0.40≤w/ceqv. ≤0.62
        a = hf.Beta_custom(0.6, 0.15, 0.0, 1.0)

    if pars.concrete_type == &#34;Blast furnace slag cement concrete&#34;:
        # CEM III/B; 0.40 ≤ w/c ≤ 0.60
        a = hf.Beta_custom(0.45, 0.20, 0.0, 1.0)

    A = (pars.t_0 / t) ** a
    return A


def D_RCM_0(pars):
    &#34;&#34;&#34; Return the chloride migration coefficient from Rapid chloride migration test [m^2/s] see NT Build 492
    if the test data is not available from pars, use intepolation of existion empirical data for orientation purpose
    Pay attention to the units output [mm^2/year], used for the model

    Parameters
    ----------
    pars.D_RCM_test    : int or float
                         RCM test results[m^2/s], the mean value from the test is used, and standard deviation is estimated based on mean
    pars.option.choose : bool
                         if true intepolation from existing data table is used
    pars.option.df_D_RCM_0  : pandas dataframe
                              experimental data table(cement type, and w/c eqv) for intepolation
    pars.option.cement_type : string
                              select cement type for data interpolation of the df_D_RCM_0
                              &#39;CEM_I_42.5_R&#39;
                              &#39;CEM_I_42.5_R+FA&#39;
                              &#39;CEM_I_42.5_R+SF&#39;
                              &#39;CEM_III/B_42.5&#39;
    pars.option.wc_eqv : float
                         equivalent water cement ratio considering supplimentary cementitious materials

    Returns
    -------
    out : numpy array
         D_RCM_0_final [mm^2/year]
    &#34;&#34;&#34;
    if isinstance(pars.D_RCM_test, int) or isinstance(pars.D_RCM_test, float):
        # though test result [m^2/s]
        D_RCM_0_mean = pars.D_RCM_test  # [m^2/s]
        D_RCM_0_std = 0.2 * D_RCM_0_mean
        D_RCM_0_temp = hf.Normal_custom(D_RCM_0_mean, D_RCM_0_std)  # [m^2/s]
    elif pars.option.choose:
        # print &#39;No test data, interpolate: orientation purpose&#39;
        df = pars.option.df_D_RCM_0
        fit_df = df[pars.option.cement_type].dropna()

        # Curve fit
        x = fit_df.index.astype(float).values
        y = fit_df.values
        # [m^2/s] #interp_extrap_f: defined function
        D_RCM_0_mean = hf.interp_extrap_f(x, y, pars.option.wc_eqv, plot=False) * 1e-12
        D_RCM_0_std = 0.2 * D_RCM_0_mean  # [m^2/s]

        D_RCM_0_temp = hf.Normal_custom(D_RCM_0_mean, D_RCM_0_std)  # [m^2/s]

    else:
        print(&#34;D_RCM_0 calculation failed.&#34;)
        sys.exit(&#34;Error message&#34;)

    # unit change [m^2/s] -&gt; [mm^2/year]  final model input
    D_RCM_0_final = 1e6 * 3600 * 24 * 365 * D_RCM_0_temp
    return D_RCM_0_final


# Built-in Data Table for data interpolation

# Data table to intepolate/extrapolate
def load_df_D_RCM():
    &#34;&#34;&#34;load the data table of the Rapid Chloride Migration(RCM) test
    for D_RCM interpolation.

    Parameters
    ----------
    None

    Returns
    -------
    Pandas Dataframe

    Notes
    -----
    &#34;&#34;&#34;
    wc_eqv = np.arange(0.35, 0.60 + (0.05 / 2), 0.05)

    df = pd.DataFrame(
        columns=[
            &#34;wc_eqv&#34;,  # water/cement ratio (equivalent)
            &#34;CEM_I_42.5_R&#34;,  # k=0
            &#34;CEM_I_42.5_R+FA&#34;,  # k=0.5
            &#34;CEM_I_42.5_R+SF&#34;,  # k=2.0
            &#34;CEM_III/B_42.5&#34;,
        ]
    )  # k=0
    df[&#34;wc_eqv&#34;] = wc_eqv
    df[&#34;CEM_I_42.5_R&#34;] = np.array([np.nan, 8.9, 10.0, 15.8, 17.9, 25.0])
    df[&#34;CEM_I_42.5_R+FA&#34;] = np.array([np.nan, 5.6, 6.9, 9.0, 10.9, 14.9])
    df[&#34;CEM_I_42.5_R+SF&#34;] = np.array([4.4, 4.8, np.nan, np.nan, 5.3, np.nan])
    df[&#34;CEM_III/B_42.5&#34;] = np.array([np.nan, 8.3, 1.9, 2.8, 3.0, 3.4])
    df = df.set_index(&#34;wc_eqv&#34;)
    return df


def C_eqv_to_C_S_0(C_eqv):
    &#34;&#34;&#34; Convert solution chloride content to saturated chloride content in concrete
    intepolate function for 300kg cement w/c=0.5 OPC. Other empirical function should be used if available

    Parameters
    ----------
    C_eqv : float
            chloride content of the solution at the surface[g/L]

    Returns
    -------
    out : float
        saturated chloride content in concrete[wt-%/cement]
    &#34;&#34;&#34;
    #  chloride content of the solution at the surface[g/L]
    x = np.array([0.0, 0.25, 0.93, 2.62, 6.14, 9.12, 13.10, 20.18, 25.03, 30.0])
    # saturated chloride content in concrete[wt-%/cement]
    y = np.array([0.0, 0.26, 0.47, 0.74, 1.13, 1.39, 1.70, 2.19, 2.49, 2.78])

    f = interp1d(x, y)
    if C_eqv &lt;= x.max():
        C_S_0 = f(C_eqv)
    else:
        print(&#34;warning: C_eqv_to_C_S_0 extrapolation used!&#34;)
        C_S_0 = hf.interp_extrap_f(x[-5:-1], y[-5:-1], C_eqv, plot=False)
    return C_S_0


# C_S: chloride content at surface = C_S_dx when dx = 0
# C_S_dx: chloride content at subsurface

# Environmental param: Potential chloride impact C_eqv
def C_eqv(pars):
    &#34;&#34;&#34; Evaluate the Potential chloride impact -&gt; equivalent chloride solution concentration, C_eqv[g/L]
        from the source of  1)marine or coastal and/or de icing salt. It is used to estimate the boundary condition C_S_dx of contineous exposure or NON-geometry-sensitive intermittent exposure

    Parameters
    ----------
    1)marine or coastal
    pars.C_0_M : natural chloirde content of sea water [g/l]

    2) de icing salt (hard to quantify)
    pars.C_0_R : average chloride content of the chloride contaminated water [g/l]
    pars.n     : average number of salting events per year [-]
    pars.C_R_i : average amount of chloride spread within one spreading event [g/m2]
    pars.h_S_i : amount of water from rain and melted snow per spreading period [l/m2]

    Returns
    -------
    out : float
          C_eqv, potential chloride impact [g/L]

    Notes
    -----
    It is used for contineous exposure or NON-geometry-sensitive intermittent exposure.
    For geometry-sensitive condition(road side splash) the tested C_max() should be used.
    &#34;&#34;&#34;
    C_0_M = pars.C_0_M

    n = pars.n
    C_R_i = pars.C_R_i
    h_S_i = pars.h_S_i

    C_0_R = (n * C_R_i) / h_S_i

    C_eqv = None
    if pars.marine:
        C_eqv = C_0_M + C_0_R
    if not pars.marine:
        C_eqv = C_0_R

    return C_eqv


# exposure condition
def C_S_0(pars):
    &#34;&#34;&#34;Return (surface) chloride satuation concentration C_S_0 [wt.-%/cement] caused by  C_eqv [g/l]

    Parameters
    ----------
    pars.C_eqv : float
                 calculated with by C_eqv(pars) [g/L]
    pars.C_eqv_to_C_S_0 : global function
                          This function is based experiment with the info of
                            * binder-specific chloride-adsorption-isotherms
                            * the concrete composition(cement/concrete ratio)
                            * potential chloride impact C_eqv [g/L]
    &#34;&#34;&#34;
    # -&gt; get the relationship
    pars.C_eqv = C_eqv(pars)
    C_S_0 = pars.C_eqv_to_C_S_0(pars.C_eqv)
    # from_a_curve(C_eqv) 300kg cement w/c=0.5 OPC
    # maybe derive from porosity and concrete density and cement ratio??????

    return C_S_0


# substitute chloride surface concentration
def C_S_dx(pars):
    &#34;&#34;&#34;return the substitute chloride surface concentration. Fick&#39;s 2nd law applies below the convection zone(depth=dx). No convection effect when dx = 0
    condition considered: continuous/intermittent expsure - &#39;submerged&#39;,&#39;leakage&#39;, &#39;spray&#39;, &#39;splash&#39; where C_S_dx = C_S_0
    convection depth dx is calucated in the dx() function externally.
    if exposure_condition_geom_sensitive is True: the observed/empirical highest chloride content in concrete C_max is used, C_max is calculated by C_max()

    Parameters
    ----------
    pars       : object/instance of wrapper class
                 contains material and environment parameters
    pars.C_S_0 : float or numpy array
                 chloride saturation concentration C_S_0 [wt.-%/cement]
                 built-in calculation with C_S_0(pars)
    pars.C_max : float
                 maximum content of chlorides within the chloride profile, [wt.-%/cement]
                 built-in calculation with C_max(pars)
    pars.exposure_condition : string
                    continuous/intermittent expsure - &#39;submerged&#39;,&#39;leakage&#39;, &#39;spray&#39;, &#39;splash&#39;

    pars.exposure_condition_geom_sensitive : bool
                 if True, the C_max is used instead of C_S_0

    Returns
    -------
    out : float or numpy arrays
          C_S_dx, the substitute chloride surface concentration [wt.-%/cement]

    &#34;&#34;&#34;
    pars.C_S_0 = C_S_0(pars)
    # transfer functions considering geometry and exposure conditions
    # C_S_dx considered as time independent for simplification
    if pars.exposure_condition in [&#34;submerged&#34;, &#34;leakage&#34;, &#34;spray&#34;]:
        # for continuous exposure, such as submerge: use transfer function dx=0
        C_S_dx = pars.C_S_0  # dx = 0, set in dx()

    elif pars.exposure_condition == &#34;splash&#34;:
        if pars.exposure_condition_geom_sensitive:
            # gelometry-sensitive road splash use C_max
            pars.C_max = C_max(pars)
            C_S_dx_mean = pars.C_max
            C_S_dx_std = 0.75 * C_S_dx_mean
            C_S_dx = hf.Normal_custom(C_S_dx_mean, C_S_dx_std, non_negative=True)
        else:
            # intermittent exposure, dx &gt;0, set in dx()
            C_S_dx = pars.C_S_0
    else:
        C_S_dx = None
        logger.warning(&#34;C_S_dx calculation failed&#34;)
    return C_S_dx


# Convection depth
def dx(pars):
    &#34;&#34;&#34;dx : convection depth [mm]&#34;&#34;&#34;
    condition = pars.exposure_condition
    dx = None
    if condition == &#34;splash&#34;:
        # - for splash conditions (splash road environment, splash marine environment)
        dx = hf.Beta_custom(5.6, 8.9, 0.0, 50.0)

    if condition in [&#34;submerged&#34;, &#34;leakage&#34;, &#34;spray&#34;]:
        # - for submerged marine structures
        # - for leakage due to seawater and constant ground water level
        # - for spray conditions(spray road environment, spray marine environment)
        #   a height of more than 1.50 m above the road (spray zone) no dx develops
        dx = 0.0

    if condition == &#34;other&#34;:
        print(&#34;to be determined&#34;)
        pass
    return dx


#  Chloride surface content CS resp. substitute chloride surface content C_S_dx
def C_max(pars):
    &#34;&#34;&#34;
    C_max: maximum content of chlorides within the chloride profile [wt.-%/cement]
    calculate from empirical equations or from test data [wt.-%/concrete]

    Parameters
    ----------
    pars.cement_concrete_ratio : float
                      cement/concrete weight ratio, used to convert [wt.-%/concrete] -&gt; [wt.-%/cement]

    pars.C_max_option : string
                        &#34;empirical&#34; - use empiricial equation
                        &#34;user_input&#34; - use user input, from test
    for &#34;empirical&#34;
        pars.x_a : horizontal distance from the roadside [cm]
        pars.x_h : height above road surface [cm]

    for &#34;user_input&#34;
        pars.C_max_user_input : Experiment-tested maximum chloride content [wt.-%/concrete]

    Returns
    -------
        C_max: maximum content of chlorides within the chloride profile, [wt.-%/cement]
    &#34;&#34;&#34;
    C_max_temp = None
    if pars.C_max_option == &#34;empirical&#34;:
        # empirical eq should be determined for structures of different exposure or concrete mixes????????
        # A typical C_max
        # – location: urban and rural areas in Germany
        # – time of exposure of the considered structure: 5-40 years
        # – concrete: CEM I, w/c = 0.45 up to w/c = 0.60,
        x_a = pars.x_a
        x_h = pars.x_h
        C_max_temp = (
            0.465 - 0.051 * np.log(x_a + 1) - (0.00065 * (x_a + 1) ** -0.187) * x_h
        )  # wt.%/concrete

    if pars.C_max_option == &#34;user_input&#34;:
        C_max_temp = pars.C_max_user_input  # wt-% concrete

    # wt.%/concrete -&gt; wt.%cement
    C_max_final = C_max_temp / pars.cement_concrete_ratio
    return C_max_final


# critical chloride content
def C_crit_param():
    &#34;&#34;&#34;return a critical chloride content(total chloride), C_crit [wt.-%/cement]: beta distributed

    Returns
    -------
    out : tuple
         parameters of general beta distribution (mean, std, lower_bound, upper_bound)
    &#34;&#34;&#34;
    C_crit_param = (0.6, 0.15, 0.2, 2.0)
    return C_crit_param


# helper function: calibration fucntion
def calibrate_chloride_f(
    model_raw,
    x,
    t,
    chloride_content,
    tol=1e-15,
    max_count=50,
    print_out=True,
    print_proc=False,
):
    &#34;&#34;&#34;calibrate chloride model to field data at one depth at one time.
    Calibrate the chloride model with field chloride test data and return the new calibrated model object/instance
    Optimization metheod:  Field chloirde content at depth x and time t -&gt; find corresponding D_RCM_0(repaid chloride migration diffusivity[m^2/s])

    Parameters
    ----------
    model_raw : object/instance of Chloride_model class (to be calibrated)
    x         : float
                depth [mm]
    t: [year] : int or float
                time [year]
    chloride_content : float or int
                       field chloride_content[wt.-%/cement] at time t, depth x,

    tol: float
         D_RCM_0 optimization absolute tolerance 1e-15 [m^2/s]

    max_count : int
         maximun number of searching iteration, default is 50
    print_out : bool
                if true, print model and field chloride content
    print_proc: bool
                if turn, print optimization process. (debug message in the logger)

    Returns
    -------
    out : object/instance of Chloride_Model class
          new calibrated model

    Notes
    -----
    calibrate model to field data at three depths in calibrate_chloride_f_group()
    chloride_content_field[wt.-%/cement] at time t
        -&gt; find corresponding D_RCM_0,
        -&gt; fixed C_S_dx(exposure type dependent)
        -&gt; (dx is determined by default model)
    &#34;&#34;&#34;
    model = model_raw.copy()
    # target chloride contnet at depth x
    cl = chloride_content

    # DCM test
    # cap
    D_RCM_test_min = 0.0
    # [m/s] unrealistically large safe ceiling cooresponding to a D_RCM_0= [94] [mm/year]
    D_RCM_test_max = 3e-12

    # optimization
    count = 0
    while D_RCM_test_max - D_RCM_test_min &gt; tol:

        # update guess
        D_RCM_test_guess = 0.5 * (D_RCM_test_min + D_RCM_test_max)
        model.pars.D_RCM_test = D_RCM_test_guess
        model.run(x, t)
        chloride_mean = hf.Get_mean(model.C_x_t)
        #         print &#39;relative tol: &#39;, (D_RCM_test_max - D_RCM_test_min)/ D_RCM_test_guess

        # compare
        if chloride_mean &lt; cl.mean():
            # narrow the cap
            D_RCM_test_min = max(D_RCM_test_guess, D_RCM_test_min)
        else:
            D_RCM_test_max = min(D_RCM_test_guess, D_RCM_test_max)

        if print_proc:
            print(&#34;chloride_mean&#34;, chloride_mean)
            print(&#34;D_RCM_test&#34;, D_RCM_test_guess)
            print(&#34;cap&#34;, (D_RCM_test_min, D_RCM_test_max))
        count += 1
        if count &gt; max_count:
            print(&#34;iteration exceeded max number of iteration: {}&#34;.format(count))
            break

    if print_out:
        print(&#34;chloride_content:&#34;)
        print(
            &#34;model: \nmean:{}\nstd:{}&#34;.format(
                hf.Get_mean(model.C_x_t), hf.Get_std(model.C_x_t)
            )
        )
        print(&#34;field: \nmean:{}\nstd:{}&#34;.format(cl.mean(), cl.std()))
    return model  # new calibrated obj


def calibrate_chloride_f_group(
    model_raw, t, chloride_content_field, plot=True, print_proc=False
):
    &#34;&#34;&#34;use calibrate_chloride_f() to calibrate model to field chloride content at three or more depths, and return the new calibrated model with the averaged D_RCM_0

    Parameters
    ----------
    model_raw : object/instance of Chloride_model class (to be calibrated)
                model_raw.copy() will be used
    chloride_content_field: pd.dataframe
                            containts field chloride contents at various depths [wt.-%/cement]
    t: int or float
        time [year]

    returns
    -------
    out : object/instance of Chloride_model class
          a new calibrated model with the averaged calibrated D_RCM_0
    &#34;&#34;&#34;
    M_cal_lis = []
    M_cal_new = None
    for i in range(len(chloride_content_field)):
        M_cal = calibrate_chloride_f(
            model_raw,
            chloride_content_field.depth.iloc[i],
            t,
            chloride_content_field.cl.iloc[i],
            print_proc=print_proc,
            print_out=False,
        )
        M_cal_lis.append(M_cal)  # M_cal is a new obj
        print(M_cal.pars.D_RCM_test)

        M_cal_new = model_raw.copy()
        M_cal_new.pars.D_RCM_test = np.mean(
            np.array([M_cal.pars.D_RCM_test for M_cal in M_cal_lis])
        )

    if plot:
        Cl_model = [
            hf.Get_mean(M_cal_new.run(depth, t))
            for depth in chloride_content_field.depth
        ]
        fig, ax = plt.subplots()
        ax.plot(
            chloride_content_field[&#34;depth&#34;],
            chloride_content_field[&#34;cl&#34;],
            &#34;--.&#34;,
            label=&#34;field&#34;,
        )
        ax.plot(
            chloride_content_field.depth, Cl_model, &#34;o&#34;, alpha=0.5, label=&#34;calibrated&#34;
        )
        ax.legend()

    return M_cal_new


def chloride_year(model, depth, year_lis, plot=True, amplify=80):
    &#34;&#34;&#34;run model over time&#34;&#34;&#34;
    t_lis = year_lis
    M_cal = model

    M_lis = []
    for t in t_lis:
        M_cal.run(depth, t)
        M_cal.postproc()
        M_lis.append(M_cal.copy())
    if plot:
        fig, [ax1, ax2, ax3] = plt.subplots(
            nrows=3,
            figsize=(8, 8),
            sharex=True,
            gridspec_kw={&#34;height_ratios&#34;: [1, 1, 3]},
        )
        # plot a few distrubtion
        indx = np.linspace(0, len(year_lis) - 1, min(6, len(year_lis))).astype(&#34;int&#34;)[
            1:
        ]
        M_sel = [M_lis[i] for i in indx]

        ax1.plot([this_M.t for this_M in M_lis], [this_M.pf for this_M in M_lis], &#34;k--&#34;)
        ax1.plot(
            [this_M.t for this_M in M_sel],
            [this_M.pf for this_M in M_sel],
            &#34;k|&#34;,
            markersize=15,
        )
        ax1.set_ylabel(&#34;Probability of failure $P_f$&#34;)

        ax2.plot(
            [this_M.t for this_M in M_lis],
            [this_M.beta_factor for this_M in M_lis],
            &#34;k--&#34;,
        )
        ax2.plot(
            [this_M.t for this_M in M_sel],
            [this_M.beta_factor for this_M in M_sel],
            &#34;k|&#34;,
            markersize=15,
        )
        ax2.set_ylabel(r&#34;Reliability factor $\beta$&#34;)

        # plot mean results
        ax3.plot(t_lis, [M.pars.C_crit_distrib_param[0] for M in M_lis], &#34;--C0&#34;)
        ax3.plot(t_lis, [hf.Get_mean(M.C_x_t) for M in M_lis], &#34;--C1&#34;)
        # plot distribution
        for this_M in M_sel:
            hf.RS_plot(this_M, ax=ax3, t_offset=this_M.t, amplify=amplify)

        import matplotlib.patches as mpatches

        R_patch = mpatches.Patch(
            color=&#34;C0&#34;, label=&#34;R: critical chloride content&#34;, alpha=0.8
        )
        S_patch = mpatches.Patch(
            color=&#34;C1&#34;, label=&#34;S: chloride content at rebar depth&#34;, alpha=0.8
        )

        ax3.set_xlabel(&#34;Time[year]&#34;)
        ax3.set_ylabel(&#34;Chloride content[wt-% cement]&#34;)
        ax3.legend(handles=[R_patch, S_patch], loc=&#34;upper left&#34;)

        plt.tight_layout()
    return [this_M.pf for this_M in M_lis], [this_M.beta_factor for this_M in M_lis]


class Chloride_Model:
    def __init__(self, pars_raw):
        # attached a deepcopy of pars_raw with user-input, then update the copy with derived parameters
        self.pars = deepcopy(pars_raw)
        self.pars.C_S_dx = C_S_dx(pars_raw)
        self.pars.dx = dx(pars_raw)

    def run(self, x, t):
        &#34;&#34;&#34;
        x[mm]
        t[year]&#34;&#34;&#34;
        self.C_x_t = Chloride_content(x, t, self.pars)
        self.x = x
        self.t = t
        return self.C_x_t

    def postproc(self, plot=False):
        sol = hf.Pf_RS(
            self.pars.C_crit_distrib_param, self.C_x_t, R_distrib_type=&#34;beta&#34;, plot=plot
        )
        self.pf = sol[0]
        self.beta_factor = sol[1]
        self.R_distrib = sol[2]
        self.S_kde_fit = sol[3]
        self.S = self.C_x_t

    def calibrate(self, t, chloride_content_field, print_proc=False, plot=True):
        &#34;&#34;&#34;

        Returns
        -------
        object
        &#34;&#34;&#34;
        model_cal = calibrate_chloride_f_group(
            self, t, chloride_content_field, print_proc=print_proc, plot=plot
        )
        return model_cal

    def copy(self):
        &#34;&#34;&#34;create a deepcopy of the instance

        Returns
        -------
        model object instance
    
        &#34;&#34;&#34;
        return deepcopy(self)

    def chloride_with_year(self, depth, year_lis, plot=True, amplify=80):
        pf_lis, beta_lis = chloride_year(
            self, depth, year_lis, plot=plot, amplify=amplify
        )
        return np.array(pf_lis), np.array(beta_lis)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Tinkrete.chloride.A_t"><code class="name flex">
<span>def <span class="ident">A_t</span></span>(<span>t, pars)</span>
</code></dt>
<dd>
<div class="desc"><p>calcuate A_t considering the ageing effect</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>time [year]</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>pars.concrete_type : string
'Portland cement concrete',
'Portland fly ash cement concrete',
'Blast furnace slag cement concrete'</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>subfunction considering the ‘ageing'[-]</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>built-in parameters
pars.k_t : transfer parameter, k_t =1 was set for experiment [-]
pars.t_0 : reference point of time, 0.0767 [year]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def A_t(t, pars):
    &#34;&#34;&#34;calcuate A_t considering the ageing effect

    Parameters
    ----------
    t : time [year]
    pars.concrete_type : string
                         &#39;Portland cement concrete&#39;,
                         &#39;Portland fly ash cement concrete&#39;,
                         &#39;Blast furnace slag cement concrete&#39;

    Returns
    -------
    out : numpy array
        subfunction considering the ‘ageing&#39;[-]

    Notes
    -----
    built-in parameters
    pars.k_t : transfer parameter, k_t =1 was set for experiment [-]
    pars.t_0 : reference point of time, 0.0767 [year]
    &#34;&#34;&#34;
    pars.t_0 = 0.0767  # reference point of time [year]
    # To carry out the quantification of a, the transfer variable k_t was set to k_t = 1:
    pars.k_t = 1
    # a: agieng exponent
    a = None
    if pars.concrete_type == &#34;Portland cement concrete&#34;:
        # CEM I; 0.40 ≤ w/c ≤ 0.60
        a = hf.Beta_custom(0.3, 0.12, 0.0, 1.0)

    if pars.concrete_type == &#34;Portland fly ash cement concrete&#34;:
        # f≥0.20·z;k=0.50; 0.40≤w/ceqv. ≤0.62
        a = hf.Beta_custom(0.6, 0.15, 0.0, 1.0)

    if pars.concrete_type == &#34;Blast furnace slag cement concrete&#34;:
        # CEM III/B; 0.40 ≤ w/c ≤ 0.60
        a = hf.Beta_custom(0.45, 0.20, 0.0, 1.0)

    A = (pars.t_0 / t) ** a
    return A</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_S_0"><code class="name flex">
<span>def <span class="ident">C_S_0</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Return (surface) chloride satuation concentration C_S_0 [wt.-%/cement] caused by
C_eqv [g/l]</p>
<h2 id="parameters">Parameters</h2>
<p>pars.C_eqv : float
calculated with by C_eqv(pars) [g/L]
pars.C_eqv_to_C_S_0 : global function
This function is based experiment with the info of
* binder-specific chloride-adsorption-isotherms
* the concrete composition(cement/concrete ratio)
* potential chloride impact C_eqv [g/L]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_S_0(pars):
    &#34;&#34;&#34;Return (surface) chloride satuation concentration C_S_0 [wt.-%/cement] caused by  C_eqv [g/l]

    Parameters
    ----------
    pars.C_eqv : float
                 calculated with by C_eqv(pars) [g/L]
    pars.C_eqv_to_C_S_0 : global function
                          This function is based experiment with the info of
                            * binder-specific chloride-adsorption-isotherms
                            * the concrete composition(cement/concrete ratio)
                            * potential chloride impact C_eqv [g/L]
    &#34;&#34;&#34;
    # -&gt; get the relationship
    pars.C_eqv = C_eqv(pars)
    C_S_0 = pars.C_eqv_to_C_S_0(pars.C_eqv)
    # from_a_curve(C_eqv) 300kg cement w/c=0.5 OPC
    # maybe derive from porosity and concrete density and cement ratio??????

    return C_S_0</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_S_dx"><code class="name flex">
<span>def <span class="ident">C_S_dx</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>return the substitute chloride surface concentration. Fick's 2nd law applies below the convection zone(depth=dx). No convection effect when dx = 0
condition considered: continuous/intermittent expsure - 'submerged','leakage', 'spray', 'splash' where C_S_dx = C_S_0
convection depth dx is calucated in the dx() function externally.
if exposure_condition_geom_sensitive is True: the observed/empirical highest chloride content in concrete C_max is used, C_max is calculated by C_max()</p>
<h2 id="parameters">Parameters</h2>
<p>pars
: object/instance of wrapper class
contains material and environment parameters
pars.C_S_0 : float or numpy array
chloride saturation concentration C_S_0 [wt.-%/cement]
built-in calculation with C_S_0(pars)
pars.C_max : float
maximum content of chlorides within the chloride profile, [wt.-%/cement]
built-in calculation with C_max(pars)
pars.exposure_condition : string
continuous/intermittent expsure - 'submerged','leakage', 'spray', 'splash'</p>
<p>pars.exposure_condition_geom_sensitive : bool
if True, the C_max is used instead of C_S_0</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>float</code> or <code>numpy arrays</code></dt>
<dd>C_S_dx, the substitute chloride surface concentration [wt.-%/cement]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_S_dx(pars):
    &#34;&#34;&#34;return the substitute chloride surface concentration. Fick&#39;s 2nd law applies below the convection zone(depth=dx). No convection effect when dx = 0
    condition considered: continuous/intermittent expsure - &#39;submerged&#39;,&#39;leakage&#39;, &#39;spray&#39;, &#39;splash&#39; where C_S_dx = C_S_0
    convection depth dx is calucated in the dx() function externally.
    if exposure_condition_geom_sensitive is True: the observed/empirical highest chloride content in concrete C_max is used, C_max is calculated by C_max()

    Parameters
    ----------
    pars       : object/instance of wrapper class
                 contains material and environment parameters
    pars.C_S_0 : float or numpy array
                 chloride saturation concentration C_S_0 [wt.-%/cement]
                 built-in calculation with C_S_0(pars)
    pars.C_max : float
                 maximum content of chlorides within the chloride profile, [wt.-%/cement]
                 built-in calculation with C_max(pars)
    pars.exposure_condition : string
                    continuous/intermittent expsure - &#39;submerged&#39;,&#39;leakage&#39;, &#39;spray&#39;, &#39;splash&#39;

    pars.exposure_condition_geom_sensitive : bool
                 if True, the C_max is used instead of C_S_0

    Returns
    -------
    out : float or numpy arrays
          C_S_dx, the substitute chloride surface concentration [wt.-%/cement]

    &#34;&#34;&#34;
    pars.C_S_0 = C_S_0(pars)
    # transfer functions considering geometry and exposure conditions
    # C_S_dx considered as time independent for simplification
    if pars.exposure_condition in [&#34;submerged&#34;, &#34;leakage&#34;, &#34;spray&#34;]:
        # for continuous exposure, such as submerge: use transfer function dx=0
        C_S_dx = pars.C_S_0  # dx = 0, set in dx()

    elif pars.exposure_condition == &#34;splash&#34;:
        if pars.exposure_condition_geom_sensitive:
            # gelometry-sensitive road splash use C_max
            pars.C_max = C_max(pars)
            C_S_dx_mean = pars.C_max
            C_S_dx_std = 0.75 * C_S_dx_mean
            C_S_dx = hf.Normal_custom(C_S_dx_mean, C_S_dx_std, non_negative=True)
        else:
            # intermittent exposure, dx &gt;0, set in dx()
            C_S_dx = pars.C_S_0
    else:
        C_S_dx = None
        logger.warning(&#34;C_S_dx calculation failed&#34;)
    return C_S_dx</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_crit_param"><code class="name flex">
<span>def <span class="ident">C_crit_param</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>return a critical chloride content(total chloride), C_crit [wt.-%/cement]: beta distributed</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>tuple</code></dt>
<dd>parameters of general beta distribution (mean, std, lower_bound, upper_bound)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_crit_param():
    &#34;&#34;&#34;return a critical chloride content(total chloride), C_crit [wt.-%/cement]: beta distributed

    Returns
    -------
    out : tuple
         parameters of general beta distribution (mean, std, lower_bound, upper_bound)
    &#34;&#34;&#34;
    C_crit_param = (0.6, 0.15, 0.2, 2.0)
    return C_crit_param</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_eqv"><code class="name flex">
<span>def <span class="ident">C_eqv</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the Potential chloride impact -&gt; equivalent chloride solution concentration, C_eqv[g/L]
from the source of
1)marine or coastal and/or de icing salt. It is used to estimate the boundary condition C_S_dx of contineous exposure or NON-geometry-sensitive intermittent exposure</p>
<h2 id="parameters">Parameters</h2>
<p>1)marine or coastal
pars.C_0_M : natural chloirde content of sea water [g/l]</p>
<p>2) de icing salt (hard to quantify)
pars.C_0_R : average chloride content of the chloride contaminated water [g/l]
pars.n
: average number of salting events per year [-]
pars.C_R_i : average amount of chloride spread within one spreading event [g/m2]
pars.h_S_i : amount of water from rain and melted snow per spreading period [l/m2]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>float</code></dt>
<dd>C_eqv, potential chloride impact [g/L]</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>It is used for contineous exposure or NON-geometry-sensitive intermittent exposure.
For geometry-sensitive condition(road side splash) the tested C_max() should be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_eqv(pars):
    &#34;&#34;&#34; Evaluate the Potential chloride impact -&gt; equivalent chloride solution concentration, C_eqv[g/L]
        from the source of  1)marine or coastal and/or de icing salt. It is used to estimate the boundary condition C_S_dx of contineous exposure or NON-geometry-sensitive intermittent exposure

    Parameters
    ----------
    1)marine or coastal
    pars.C_0_M : natural chloirde content of sea water [g/l]

    2) de icing salt (hard to quantify)
    pars.C_0_R : average chloride content of the chloride contaminated water [g/l]
    pars.n     : average number of salting events per year [-]
    pars.C_R_i : average amount of chloride spread within one spreading event [g/m2]
    pars.h_S_i : amount of water from rain and melted snow per spreading period [l/m2]

    Returns
    -------
    out : float
          C_eqv, potential chloride impact [g/L]

    Notes
    -----
    It is used for contineous exposure or NON-geometry-sensitive intermittent exposure.
    For geometry-sensitive condition(road side splash) the tested C_max() should be used.
    &#34;&#34;&#34;
    C_0_M = pars.C_0_M

    n = pars.n
    C_R_i = pars.C_R_i
    h_S_i = pars.h_S_i

    C_0_R = (n * C_R_i) / h_S_i

    C_eqv = None
    if pars.marine:
        C_eqv = C_0_M + C_0_R
    if not pars.marine:
        C_eqv = C_0_R

    return C_eqv</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_eqv_to_C_S_0"><code class="name flex">
<span>def <span class="ident">C_eqv_to_C_S_0</span></span>(<span>C_eqv)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert solution chloride content to saturated chloride content in concrete
intepolate function for 300kg cement w/c=0.5 OPC. Other empirical function should be used if available</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C_eqv</code></strong> :&ensp;<code>float</code></dt>
<dd>chloride content of the solution at the surface[g/L]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>float</code></dt>
<dd>saturated chloride content in concrete[wt-%/cement]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_eqv_to_C_S_0(C_eqv):
    &#34;&#34;&#34; Convert solution chloride content to saturated chloride content in concrete
    intepolate function for 300kg cement w/c=0.5 OPC. Other empirical function should be used if available

    Parameters
    ----------
    C_eqv : float
            chloride content of the solution at the surface[g/L]

    Returns
    -------
    out : float
        saturated chloride content in concrete[wt-%/cement]
    &#34;&#34;&#34;
    #  chloride content of the solution at the surface[g/L]
    x = np.array([0.0, 0.25, 0.93, 2.62, 6.14, 9.12, 13.10, 20.18, 25.03, 30.0])
    # saturated chloride content in concrete[wt-%/cement]
    y = np.array([0.0, 0.26, 0.47, 0.74, 1.13, 1.39, 1.70, 2.19, 2.49, 2.78])

    f = interp1d(x, y)
    if C_eqv &lt;= x.max():
        C_S_0 = f(C_eqv)
    else:
        print(&#34;warning: C_eqv_to_C_S_0 extrapolation used!&#34;)
        C_S_0 = hf.interp_extrap_f(x[-5:-1], y[-5:-1], C_eqv, plot=False)
    return C_S_0</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.C_max"><code class="name flex">
<span>def <span class="ident">C_max</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>C_max: maximum content of chlorides within the chloride profile [wt.-%/cement]
calculate from empirical equations or from test data [wt.-%/concrete]</p>
<h2 id="parameters">Parameters</h2>
<p>pars.cement_concrete_ratio : float
cement/concrete weight ratio, used to convert [wt.-%/concrete] -&gt; [wt.-%/cement]</p>
<p>pars.C_max_option : string
"empirical" - use empiricial equation
"user_input" - use user input, from test
for "empirical"
pars.x_a : horizontal distance from the roadside [cm]
pars.x_h : height above road surface [cm]</p>
<p>for "user_input"
pars.C_max_user_input : Experiment-tested maximum chloride content [wt.-%/concrete]</p>
<h2 id="returns">Returns</h2>
<pre><code>C_max: maximum content of chlorides within the chloride profile, [wt.-%/cement]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def C_max(pars):
    &#34;&#34;&#34;
    C_max: maximum content of chlorides within the chloride profile [wt.-%/cement]
    calculate from empirical equations or from test data [wt.-%/concrete]

    Parameters
    ----------
    pars.cement_concrete_ratio : float
                      cement/concrete weight ratio, used to convert [wt.-%/concrete] -&gt; [wt.-%/cement]

    pars.C_max_option : string
                        &#34;empirical&#34; - use empiricial equation
                        &#34;user_input&#34; - use user input, from test
    for &#34;empirical&#34;
        pars.x_a : horizontal distance from the roadside [cm]
        pars.x_h : height above road surface [cm]

    for &#34;user_input&#34;
        pars.C_max_user_input : Experiment-tested maximum chloride content [wt.-%/concrete]

    Returns
    -------
        C_max: maximum content of chlorides within the chloride profile, [wt.-%/cement]
    &#34;&#34;&#34;
    C_max_temp = None
    if pars.C_max_option == &#34;empirical&#34;:
        # empirical eq should be determined for structures of different exposure or concrete mixes????????
        # A typical C_max
        # – location: urban and rural areas in Germany
        # – time of exposure of the considered structure: 5-40 years
        # – concrete: CEM I, w/c = 0.45 up to w/c = 0.60,
        x_a = pars.x_a
        x_h = pars.x_h
        C_max_temp = (
            0.465 - 0.051 * np.log(x_a + 1) - (0.00065 * (x_a + 1) ** -0.187) * x_h
        )  # wt.%/concrete

    if pars.C_max_option == &#34;user_input&#34;:
        C_max_temp = pars.C_max_user_input  # wt-% concrete

    # wt.%/concrete -&gt; wt.%cement
    C_max_final = C_max_temp / pars.cement_concrete_ratio
    return C_max_final</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.Chloride_content"><code class="name flex">
<span>def <span class="ident">Chloride_content</span></span>(<span>x, t, pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Master model function, calculate chloride content at depth x and time t with Fick's 2nd law below the convection zone (x &gt; dx)
The derived parameters is also calculated within this funcion.
Caution: The pars instance is mutable, so a deepcopy of the original instance should be used if the calculation is not intended for "inplace".</p>
<h2 id="parameters">Parameters</h2>
<p>x
: depth where chloride content is C_x_t [mm]
t
: time [year]
pars
: object/instance of wrapper class(empty class)
a wrapper of all material and evironmental parameters deep-copied from the raw data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>chloride content in concrete at a depth x (suface x=0) at time t [wt-.%/c]</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>intermediate parameters calcualted and attached to pars
C_0
: initial chloride content of the concrete [wt-.%/cement]
C_S_dx : chloride content at a depth dx and a certain point of time t [wt-.%/cement]
dx
: depth of the convection zone (concrete layer, up to which the process of chloride penetration differs from Fick’s 2nd law of diffusion) [mm]
D_app
: apparent coefficient of chloride diffusion through concxrete [mm^2/year]
erf
: imported error function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Chloride_content(x, t, pars):
    &#34;&#34;&#34; Master model function, calculate chloride content at depth x and time t with Fick&#39;s 2nd law below the convection zone (x &gt; dx)
    The derived parameters is also calculated within this funcion.
    Caution: The pars instance is mutable, so a deepcopy of the original instance should be used if the calculation is not intended for &#34;inplace&#34;.

    Parameters
    ----------
    x      : depth where chloride content is C_x_t [mm]
    t      : time [year]
    pars   : object/instance of wrapper class(empty class)
                a wrapper of all material and evironmental parameters deep-copied from the raw data

    Returns
    -------
    out : chloride content in concrete at a depth x (suface x=0) at time t [wt-.%/c]

    Notes
    -----
    intermediate parameters calcualted and attached to pars
    C_0    : initial chloride content of the concrete [wt-.%/cement]
    C_S_dx : chloride content at a depth dx and a certain point of time t [wt-.%/cement]
    dx     : depth of the convection zone (concrete layer, up to which the process of chloride penetration differs from Fick’s 2nd law of diffusion) [mm]
    D_app  : apparent coefficient of chloride diffusion through concxrete [mm^2/year]
    erf    : imported error function
    &#34;&#34;&#34;
    pars.D_app = D_app(t, pars)
    C_x_t = pars.C_0 + (pars.C_S_dx - pars.C_0) * (
        1 - erf((x - pars.dx) / (2 * (pars.D_app * t) ** 0.5))
    )
    return C_x_t</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.D_RCM_0"><code class="name flex">
<span>def <span class="ident">D_RCM_0</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the chloride migration coefficient from Rapid chloride migration test [m^2/s] see NT Build 492
if the test data is not available from pars, use intepolation of existion empirical data for orientation purpose
Pay attention to the units output [mm^2/year], used for the model</p>
<h2 id="parameters">Parameters</h2>
<p>pars.D_RCM_test
: int or float
RCM test results[m^2/s], the mean value from the test is used, and standard deviation is estimated based on mean
pars.option.choose : bool
if true intepolation from existing data table is used
pars.option.df_D_RCM_0
: pandas dataframe
experimental data table(cement type, and w/c eqv) for intepolation
pars.option.cement_type : string
select cement type for data interpolation of the df_D_RCM_0
'CEM_I_42.5_R'
'CEM_I_42.5_R+FA'
'CEM_I_42.5_R+SF'
'CEM_III/B_42.5'
pars.option.wc_eqv : float
equivalent water cement ratio considering supplimentary cementitious materials</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>D_RCM_0_final [mm^2/year]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def D_RCM_0(pars):
    &#34;&#34;&#34; Return the chloride migration coefficient from Rapid chloride migration test [m^2/s] see NT Build 492
    if the test data is not available from pars, use intepolation of existion empirical data for orientation purpose
    Pay attention to the units output [mm^2/year], used for the model

    Parameters
    ----------
    pars.D_RCM_test    : int or float
                         RCM test results[m^2/s], the mean value from the test is used, and standard deviation is estimated based on mean
    pars.option.choose : bool
                         if true intepolation from existing data table is used
    pars.option.df_D_RCM_0  : pandas dataframe
                              experimental data table(cement type, and w/c eqv) for intepolation
    pars.option.cement_type : string
                              select cement type for data interpolation of the df_D_RCM_0
                              &#39;CEM_I_42.5_R&#39;
                              &#39;CEM_I_42.5_R+FA&#39;
                              &#39;CEM_I_42.5_R+SF&#39;
                              &#39;CEM_III/B_42.5&#39;
    pars.option.wc_eqv : float
                         equivalent water cement ratio considering supplimentary cementitious materials

    Returns
    -------
    out : numpy array
         D_RCM_0_final [mm^2/year]
    &#34;&#34;&#34;
    if isinstance(pars.D_RCM_test, int) or isinstance(pars.D_RCM_test, float):
        # though test result [m^2/s]
        D_RCM_0_mean = pars.D_RCM_test  # [m^2/s]
        D_RCM_0_std = 0.2 * D_RCM_0_mean
        D_RCM_0_temp = hf.Normal_custom(D_RCM_0_mean, D_RCM_0_std)  # [m^2/s]
    elif pars.option.choose:
        # print &#39;No test data, interpolate: orientation purpose&#39;
        df = pars.option.df_D_RCM_0
        fit_df = df[pars.option.cement_type].dropna()

        # Curve fit
        x = fit_df.index.astype(float).values
        y = fit_df.values
        # [m^2/s] #interp_extrap_f: defined function
        D_RCM_0_mean = hf.interp_extrap_f(x, y, pars.option.wc_eqv, plot=False) * 1e-12
        D_RCM_0_std = 0.2 * D_RCM_0_mean  # [m^2/s]

        D_RCM_0_temp = hf.Normal_custom(D_RCM_0_mean, D_RCM_0_std)  # [m^2/s]

    else:
        print(&#34;D_RCM_0 calculation failed.&#34;)
        sys.exit(&#34;Error message&#34;)

    # unit change [m^2/s] -&gt; [mm^2/year]  final model input
    D_RCM_0_final = 1e6 * 3600 * 24 * 365 * D_RCM_0_temp
    return D_RCM_0_final</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.D_app"><code class="name flex">
<span>def <span class="ident">D_app</span></span>(<span>t, pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the apparent coefficient of chloride diffusion through concxrete D_app[mm^2/year]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>time [year]</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>pars
: object/instance of wrapper class(empty class)
a wrapper of all material and evironmental parameters deep-copied from the raw data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>apparent coefficient of chloride diffusion through concxrete [mm^2/year]</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>intermediate parameters calcualted and attached to pars
k_e
: environmental transfer variable [-]
D_RCM_0 : chloride migration coefficient [mm^2/year]
k_t
: transfer parameter, k_t =1 was set in A_t()[-]
A_t
: subfunction considering the 'ageing' [-]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def D_app(t, pars):
    &#34;&#34;&#34; Calculate the apparent coefficient of chloride diffusion through concxrete D_app[mm^2/year]

    Parameters
    ----------
    t : time [year]
    pars   : object/instance of wrapper class(empty class)
               a wrapper of all material and evironmental parameters deep-copied from the raw data

    Returns
    -------
    out : numpy array
        apparent coefficient of chloride diffusion through concxrete [mm^2/year]

    Notes
    -----
    intermediate parameters calcualted and attached to pars
    k_e     : environmental transfer variable [-]
    D_RCM_0 : chloride migration coefficient [mm^2/year]
    k_t     : transfer parameter, k_t =1 was set in A_t()[-]
    A_t     : subfunction considering the &#39;ageing&#39; [-]
    &#34;&#34;&#34;
    pars.k_e = k_e(pars)
    pars.D_RCM_0 = D_RCM_0(pars)

    pars.A_t = A_t(t, pars)  # pars.k_t =1 was set in A_t()
    D_app = pars.k_e * pars.D_RCM_0 * pars.k_t * pars.A_t
    return D_app</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.b_e"><code class="name flex">
<span>def <span class="ident">b_e</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate b_e : regression varible [K]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def b_e():
    &#34;&#34;&#34;calculate b_e : regression varible [K]&#34;&#34;&#34;
    b_e = hf.Normal_custom(4800, 700)  # K
    return b_e</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.calibrate_chloride_f"><code class="name flex">
<span>def <span class="ident">calibrate_chloride_f</span></span>(<span>model_raw, x, t, chloride_content, tol=1e-15, max_count=50, print_out=True, print_proc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>calibrate chloride model to field data at one depth at one time.
Calibrate the chloride model with field chloride test data and return the new calibrated model object/instance
Optimization metheod:
Field chloirde content at depth x and time t -&gt; find corresponding D_RCM_0(repaid chloride migration diffusivity[m^2/s])</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_raw</code></strong> :&ensp;<code>object/instance</code> of <code>Chloride_model class (to be calibrated)</code></dt>
<dd>&nbsp;</dd>
<dt>x
: float</dt>
<dt>depth [mm]</dt>
<dt><strong><code>t</code></strong> :&ensp;<code>[year] : int</code> or <code>float</code></dt>
<dd>time [year]</dd>
<dt><strong><code>chloride_content</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>field chloride_content[wt.-%/cement] at time t, depth x,</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>D_RCM_0 optimization absolute tolerance 1e-15 [m^2/s]</dd>
<dt><strong><code>max_count</code></strong> :&ensp;<code>int</code></dt>
<dd>maximun number of searching iteration, default is 50</dd>
<dt><strong><code>print_out</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true, print model and field chloride content</dd>
<dt><strong><code>print_proc</code></strong> :&ensp;<code>bool</code></dt>
<dd>if turn, print optimization process. (debug message in the logger)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>object/instance</code> of <code><a title="Tinkrete.chloride.Chloride_Model" href="#Tinkrete.chloride.Chloride_Model">Chloride_Model</a> class</code></dt>
<dd>new calibrated model</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>calibrate model to field data at three depths in calibrate_chloride_f_group()
chloride_content_field[wt.-%/cement] at time t
-&gt; find corresponding D_RCM_0,
-&gt; fixed C_S_dx(exposure type dependent)
-&gt; (dx is determined by default model)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate_chloride_f(
    model_raw,
    x,
    t,
    chloride_content,
    tol=1e-15,
    max_count=50,
    print_out=True,
    print_proc=False,
):
    &#34;&#34;&#34;calibrate chloride model to field data at one depth at one time.
    Calibrate the chloride model with field chloride test data and return the new calibrated model object/instance
    Optimization metheod:  Field chloirde content at depth x and time t -&gt; find corresponding D_RCM_0(repaid chloride migration diffusivity[m^2/s])

    Parameters
    ----------
    model_raw : object/instance of Chloride_model class (to be calibrated)
    x         : float
                depth [mm]
    t: [year] : int or float
                time [year]
    chloride_content : float or int
                       field chloride_content[wt.-%/cement] at time t, depth x,

    tol: float
         D_RCM_0 optimization absolute tolerance 1e-15 [m^2/s]

    max_count : int
         maximun number of searching iteration, default is 50
    print_out : bool
                if true, print model and field chloride content
    print_proc: bool
                if turn, print optimization process. (debug message in the logger)

    Returns
    -------
    out : object/instance of Chloride_Model class
          new calibrated model

    Notes
    -----
    calibrate model to field data at three depths in calibrate_chloride_f_group()
    chloride_content_field[wt.-%/cement] at time t
        -&gt; find corresponding D_RCM_0,
        -&gt; fixed C_S_dx(exposure type dependent)
        -&gt; (dx is determined by default model)
    &#34;&#34;&#34;
    model = model_raw.copy()
    # target chloride contnet at depth x
    cl = chloride_content

    # DCM test
    # cap
    D_RCM_test_min = 0.0
    # [m/s] unrealistically large safe ceiling cooresponding to a D_RCM_0= [94] [mm/year]
    D_RCM_test_max = 3e-12

    # optimization
    count = 0
    while D_RCM_test_max - D_RCM_test_min &gt; tol:

        # update guess
        D_RCM_test_guess = 0.5 * (D_RCM_test_min + D_RCM_test_max)
        model.pars.D_RCM_test = D_RCM_test_guess
        model.run(x, t)
        chloride_mean = hf.Get_mean(model.C_x_t)
        #         print &#39;relative tol: &#39;, (D_RCM_test_max - D_RCM_test_min)/ D_RCM_test_guess

        # compare
        if chloride_mean &lt; cl.mean():
            # narrow the cap
            D_RCM_test_min = max(D_RCM_test_guess, D_RCM_test_min)
        else:
            D_RCM_test_max = min(D_RCM_test_guess, D_RCM_test_max)

        if print_proc:
            print(&#34;chloride_mean&#34;, chloride_mean)
            print(&#34;D_RCM_test&#34;, D_RCM_test_guess)
            print(&#34;cap&#34;, (D_RCM_test_min, D_RCM_test_max))
        count += 1
        if count &gt; max_count:
            print(&#34;iteration exceeded max number of iteration: {}&#34;.format(count))
            break

    if print_out:
        print(&#34;chloride_content:&#34;)
        print(
            &#34;model: \nmean:{}\nstd:{}&#34;.format(
                hf.Get_mean(model.C_x_t), hf.Get_std(model.C_x_t)
            )
        )
        print(&#34;field: \nmean:{}\nstd:{}&#34;.format(cl.mean(), cl.std()))
    return model  # new calibrated obj</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.calibrate_chloride_f_group"><code class="name flex">
<span>def <span class="ident">calibrate_chloride_f_group</span></span>(<span>model_raw, t, chloride_content_field, plot=True, print_proc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>use calibrate_chloride_f() to calibrate model to field chloride content at three or more depths, and return the new calibrated model with the averaged D_RCM_0</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_raw</code></strong> :&ensp;<code>object/instance</code> of <code>Chloride_model class (to be calibrated)</code></dt>
<dd>model_raw.copy() will be used</dd>
<dt><strong><code>chloride_content_field</code></strong> :&ensp;<code>pd.dataframe</code></dt>
<dd>containts field chloride contents at various depths [wt.-%/cement]</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>time [year]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>object/instance</code> of <code>Chloride_model class</code></dt>
<dd>a new calibrated model with the averaged calibrated D_RCM_0</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate_chloride_f_group(
    model_raw, t, chloride_content_field, plot=True, print_proc=False
):
    &#34;&#34;&#34;use calibrate_chloride_f() to calibrate model to field chloride content at three or more depths, and return the new calibrated model with the averaged D_RCM_0

    Parameters
    ----------
    model_raw : object/instance of Chloride_model class (to be calibrated)
                model_raw.copy() will be used
    chloride_content_field: pd.dataframe
                            containts field chloride contents at various depths [wt.-%/cement]
    t: int or float
        time [year]

    returns
    -------
    out : object/instance of Chloride_model class
          a new calibrated model with the averaged calibrated D_RCM_0
    &#34;&#34;&#34;
    M_cal_lis = []
    M_cal_new = None
    for i in range(len(chloride_content_field)):
        M_cal = calibrate_chloride_f(
            model_raw,
            chloride_content_field.depth.iloc[i],
            t,
            chloride_content_field.cl.iloc[i],
            print_proc=print_proc,
            print_out=False,
        )
        M_cal_lis.append(M_cal)  # M_cal is a new obj
        print(M_cal.pars.D_RCM_test)

        M_cal_new = model_raw.copy()
        M_cal_new.pars.D_RCM_test = np.mean(
            np.array([M_cal.pars.D_RCM_test for M_cal in M_cal_lis])
        )

    if plot:
        Cl_model = [
            hf.Get_mean(M_cal_new.run(depth, t))
            for depth in chloride_content_field.depth
        ]
        fig, ax = plt.subplots()
        ax.plot(
            chloride_content_field[&#34;depth&#34;],
            chloride_content_field[&#34;cl&#34;],
            &#34;--.&#34;,
            label=&#34;field&#34;,
        )
        ax.plot(
            chloride_content_field.depth, Cl_model, &#34;o&#34;, alpha=0.5, label=&#34;calibrated&#34;
        )
        ax.legend()

    return M_cal_new</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.chloride_year"><code class="name flex">
<span>def <span class="ident">chloride_year</span></span>(<span>model, depth, year_lis, plot=True, amplify=80)</span>
</code></dt>
<dd>
<div class="desc"><p>run model over time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chloride_year(model, depth, year_lis, plot=True, amplify=80):
    &#34;&#34;&#34;run model over time&#34;&#34;&#34;
    t_lis = year_lis
    M_cal = model

    M_lis = []
    for t in t_lis:
        M_cal.run(depth, t)
        M_cal.postproc()
        M_lis.append(M_cal.copy())
    if plot:
        fig, [ax1, ax2, ax3] = plt.subplots(
            nrows=3,
            figsize=(8, 8),
            sharex=True,
            gridspec_kw={&#34;height_ratios&#34;: [1, 1, 3]},
        )
        # plot a few distrubtion
        indx = np.linspace(0, len(year_lis) - 1, min(6, len(year_lis))).astype(&#34;int&#34;)[
            1:
        ]
        M_sel = [M_lis[i] for i in indx]

        ax1.plot([this_M.t for this_M in M_lis], [this_M.pf for this_M in M_lis], &#34;k--&#34;)
        ax1.plot(
            [this_M.t for this_M in M_sel],
            [this_M.pf for this_M in M_sel],
            &#34;k|&#34;,
            markersize=15,
        )
        ax1.set_ylabel(&#34;Probability of failure $P_f$&#34;)

        ax2.plot(
            [this_M.t for this_M in M_lis],
            [this_M.beta_factor for this_M in M_lis],
            &#34;k--&#34;,
        )
        ax2.plot(
            [this_M.t for this_M in M_sel],
            [this_M.beta_factor for this_M in M_sel],
            &#34;k|&#34;,
            markersize=15,
        )
        ax2.set_ylabel(r&#34;Reliability factor $\beta$&#34;)

        # plot mean results
        ax3.plot(t_lis, [M.pars.C_crit_distrib_param[0] for M in M_lis], &#34;--C0&#34;)
        ax3.plot(t_lis, [hf.Get_mean(M.C_x_t) for M in M_lis], &#34;--C1&#34;)
        # plot distribution
        for this_M in M_sel:
            hf.RS_plot(this_M, ax=ax3, t_offset=this_M.t, amplify=amplify)

        import matplotlib.patches as mpatches

        R_patch = mpatches.Patch(
            color=&#34;C0&#34;, label=&#34;R: critical chloride content&#34;, alpha=0.8
        )
        S_patch = mpatches.Patch(
            color=&#34;C1&#34;, label=&#34;S: chloride content at rebar depth&#34;, alpha=0.8
        )

        ax3.set_xlabel(&#34;Time[year]&#34;)
        ax3.set_ylabel(&#34;Chloride content[wt-% cement]&#34;)
        ax3.legend(handles=[R_patch, S_patch], loc=&#34;upper left&#34;)

        plt.tight_layout()
    return [this_M.pf for this_M in M_lis], [this_M.beta_factor for this_M in M_lis]</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.dx"><code class="name flex">
<span>def <span class="ident">dx</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>dx : convection depth [mm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dx(pars):
    &#34;&#34;&#34;dx : convection depth [mm]&#34;&#34;&#34;
    condition = pars.exposure_condition
    dx = None
    if condition == &#34;splash&#34;:
        # - for splash conditions (splash road environment, splash marine environment)
        dx = hf.Beta_custom(5.6, 8.9, 0.0, 50.0)

    if condition in [&#34;submerged&#34;, &#34;leakage&#34;, &#34;spray&#34;]:
        # - for submerged marine structures
        # - for leakage due to seawater and constant ground water level
        # - for spray conditions(spray road environment, spray marine environment)
        #   a height of more than 1.50 m above the road (spray zone) no dx develops
        dx = 0.0

    if condition == &#34;other&#34;:
        print(&#34;to be determined&#34;)
        pass
    return dx</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.k_e"><code class="name flex">
<span>def <span class="ident">k_e</span></span>(<span>pars)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate k_e: environmental transfer variable [-]</p>
<h2 id="parameters">Parameters</h2>
<p>pars.T_ref
: standard test temperatrure 293 [K]
pars.T_real : temperature of the structural element [K]
pars.b_e
: regression varible [K]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def k_e(pars):
    &#34;&#34;&#34;Calculate k_e: environmental transfer variable [-]

    Parameters
    ----------
    pars.T_ref  : standard test temperatrure 293 [K]
    pars.T_real : temperature of the structural element [K]
    pars.b_e    : regression varible [K]
    &#34;&#34;&#34;
    pars.T_ref = 293  # K (20°C)
    pars.b_e = b_e()
    k_e = np.e ** (pars.b_e * (1 / pars.T_ref - 1 / pars.T_real))
    return k_e</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.load_df_D_RCM"><code class="name flex">
<span>def <span class="ident">load_df_D_RCM</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>load the data table of the Rapid Chloride Migration(RCM) test
for D_RCM interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas Dataframe</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_df_D_RCM():
    &#34;&#34;&#34;load the data table of the Rapid Chloride Migration(RCM) test
    for D_RCM interpolation.

    Parameters
    ----------
    None

    Returns
    -------
    Pandas Dataframe

    Notes
    -----
    &#34;&#34;&#34;
    wc_eqv = np.arange(0.35, 0.60 + (0.05 / 2), 0.05)

    df = pd.DataFrame(
        columns=[
            &#34;wc_eqv&#34;,  # water/cement ratio (equivalent)
            &#34;CEM_I_42.5_R&#34;,  # k=0
            &#34;CEM_I_42.5_R+FA&#34;,  # k=0.5
            &#34;CEM_I_42.5_R+SF&#34;,  # k=2.0
            &#34;CEM_III/B_42.5&#34;,
        ]
    )  # k=0
    df[&#34;wc_eqv&#34;] = wc_eqv
    df[&#34;CEM_I_42.5_R&#34;] = np.array([np.nan, 8.9, 10.0, 15.8, 17.9, 25.0])
    df[&#34;CEM_I_42.5_R+FA&#34;] = np.array([np.nan, 5.6, 6.9, 9.0, 10.9, 14.9])
    df[&#34;CEM_I_42.5_R+SF&#34;] = np.array([4.4, 4.8, np.nan, np.nan, 5.3, np.nan])
    df[&#34;CEM_III/B_42.5&#34;] = np.array([np.nan, 8.3, 1.9, 2.8, 3.0, 3.4])
    df = df.set_index(&#34;wc_eqv&#34;)
    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Tinkrete.chloride.Chloride_Model"><code class="flex name class">
<span>class <span class="ident">Chloride_Model</span></span>
<span>(</span><span>pars_raw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chloride_Model:
    def __init__(self, pars_raw):
        # attached a deepcopy of pars_raw with user-input, then update the copy with derived parameters
        self.pars = deepcopy(pars_raw)
        self.pars.C_S_dx = C_S_dx(pars_raw)
        self.pars.dx = dx(pars_raw)

    def run(self, x, t):
        &#34;&#34;&#34;
        x[mm]
        t[year]&#34;&#34;&#34;
        self.C_x_t = Chloride_content(x, t, self.pars)
        self.x = x
        self.t = t
        return self.C_x_t

    def postproc(self, plot=False):
        sol = hf.Pf_RS(
            self.pars.C_crit_distrib_param, self.C_x_t, R_distrib_type=&#34;beta&#34;, plot=plot
        )
        self.pf = sol[0]
        self.beta_factor = sol[1]
        self.R_distrib = sol[2]
        self.S_kde_fit = sol[3]
        self.S = self.C_x_t

    def calibrate(self, t, chloride_content_field, print_proc=False, plot=True):
        &#34;&#34;&#34;

        Returns
        -------
        object
        &#34;&#34;&#34;
        model_cal = calibrate_chloride_f_group(
            self, t, chloride_content_field, print_proc=print_proc, plot=plot
        )
        return model_cal

    def copy(self):
        &#34;&#34;&#34;create a deepcopy of the instance

        Returns
        -------
        model object instance
    
        &#34;&#34;&#34;
        return deepcopy(self)

    def chloride_with_year(self, depth, year_lis, plot=True, amplify=80):
        pf_lis, beta_lis = chloride_year(
            self, depth, year_lis, plot=plot, amplify=amplify
        )
        return np.array(pf_lis), np.array(beta_lis)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Tinkrete.chloride.Chloride_Model.calibrate"><code class="name flex">
<span>def <span class="ident">calibrate</span></span>(<span>self, t, chloride_content_field, print_proc=False, plot=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate(self, t, chloride_content_field, print_proc=False, plot=True):
    &#34;&#34;&#34;

    Returns
    -------
    object
    &#34;&#34;&#34;
    model_cal = calibrate_chloride_f_group(
        self, t, chloride_content_field, print_proc=print_proc, plot=plot
    )
    return model_cal</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.Chloride_Model.chloride_with_year"><code class="name flex">
<span>def <span class="ident">chloride_with_year</span></span>(<span>self, depth, year_lis, plot=True, amplify=80)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chloride_with_year(self, depth, year_lis, plot=True, amplify=80):
    pf_lis, beta_lis = chloride_year(
        self, depth, year_lis, plot=plot, amplify=amplify
    )
    return np.array(pf_lis), np.array(beta_lis)</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.Chloride_Model.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a deepcopy of the instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>model object instance</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;create a deepcopy of the instance

    Returns
    -------
    model object instance

    &#34;&#34;&#34;
    return deepcopy(self)</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.Chloride_Model.postproc"><code class="name flex">
<span>def <span class="ident">postproc</span></span>(<span>self, plot=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postproc(self, plot=False):
    sol = hf.Pf_RS(
        self.pars.C_crit_distrib_param, self.C_x_t, R_distrib_type=&#34;beta&#34;, plot=plot
    )
    self.pf = sol[0]
    self.beta_factor = sol[1]
    self.R_distrib = sol[2]
    self.S_kde_fit = sol[3]
    self.S = self.C_x_t</code></pre>
</details>
</dd>
<dt id="Tinkrete.chloride.Chloride_Model.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, x, t)</span>
</code></dt>
<dd>
<div class="desc"><p>x[mm]
t[year]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, x, t):
    &#34;&#34;&#34;
    x[mm]
    t[year]&#34;&#34;&#34;
    self.C_x_t = Chloride_content(x, t, self.pars)
    self.x = x
    self.t = t
    return self.C_x_t</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Tinkrete" href="index.html">Tinkrete</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Tinkrete.chloride.A_t" href="#Tinkrete.chloride.A_t">A_t</a></code></li>
<li><code><a title="Tinkrete.chloride.C_S_0" href="#Tinkrete.chloride.C_S_0">C_S_0</a></code></li>
<li><code><a title="Tinkrete.chloride.C_S_dx" href="#Tinkrete.chloride.C_S_dx">C_S_dx</a></code></li>
<li><code><a title="Tinkrete.chloride.C_crit_param" href="#Tinkrete.chloride.C_crit_param">C_crit_param</a></code></li>
<li><code><a title="Tinkrete.chloride.C_eqv" href="#Tinkrete.chloride.C_eqv">C_eqv</a></code></li>
<li><code><a title="Tinkrete.chloride.C_eqv_to_C_S_0" href="#Tinkrete.chloride.C_eqv_to_C_S_0">C_eqv_to_C_S_0</a></code></li>
<li><code><a title="Tinkrete.chloride.C_max" href="#Tinkrete.chloride.C_max">C_max</a></code></li>
<li><code><a title="Tinkrete.chloride.Chloride_content" href="#Tinkrete.chloride.Chloride_content">Chloride_content</a></code></li>
<li><code><a title="Tinkrete.chloride.D_RCM_0" href="#Tinkrete.chloride.D_RCM_0">D_RCM_0</a></code></li>
<li><code><a title="Tinkrete.chloride.D_app" href="#Tinkrete.chloride.D_app">D_app</a></code></li>
<li><code><a title="Tinkrete.chloride.b_e" href="#Tinkrete.chloride.b_e">b_e</a></code></li>
<li><code><a title="Tinkrete.chloride.calibrate_chloride_f" href="#Tinkrete.chloride.calibrate_chloride_f">calibrate_chloride_f</a></code></li>
<li><code><a title="Tinkrete.chloride.calibrate_chloride_f_group" href="#Tinkrete.chloride.calibrate_chloride_f_group">calibrate_chloride_f_group</a></code></li>
<li><code><a title="Tinkrete.chloride.chloride_year" href="#Tinkrete.chloride.chloride_year">chloride_year</a></code></li>
<li><code><a title="Tinkrete.chloride.dx" href="#Tinkrete.chloride.dx">dx</a></code></li>
<li><code><a title="Tinkrete.chloride.k_e" href="#Tinkrete.chloride.k_e">k_e</a></code></li>
<li><code><a title="Tinkrete.chloride.load_df_D_RCM" href="#Tinkrete.chloride.load_df_D_RCM">load_df_D_RCM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Tinkrete.chloride.Chloride_Model" href="#Tinkrete.chloride.Chloride_Model">Chloride_Model</a></code></h4>
<ul class="">
<li><code><a title="Tinkrete.chloride.Chloride_Model.calibrate" href="#Tinkrete.chloride.Chloride_Model.calibrate">calibrate</a></code></li>
<li><code><a title="Tinkrete.chloride.Chloride_Model.chloride_with_year" href="#Tinkrete.chloride.Chloride_Model.chloride_with_year">chloride_with_year</a></code></li>
<li><code><a title="Tinkrete.chloride.Chloride_Model.copy" href="#Tinkrete.chloride.Chloride_Model.copy">copy</a></code></li>
<li><code><a title="Tinkrete.chloride.Chloride_Model.postproc" href="#Tinkrete.chloride.Chloride_Model.postproc">postproc</a></code></li>
<li><code><a title="Tinkrete.chloride.Chloride_Model.run" href="#Tinkrete.chloride.Chloride_Model.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>